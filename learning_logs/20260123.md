# 📂 01.23 수업 내용  
# 📍 안내사항

# 🟦 조건문

## 🔷 if-else if-else

## 🔷 switch
switch문에서는 조건문과 달리 비교 연산을 통한 true / false를 뽑아내는 식이 switch()의 소괄호 내에 들어가지 않는다.
```js
switch(변수/상수) {
  case 값1:
    실행문1
    break;
  case 값2:
    실행문2
    break;
  default:
    실행문default
    (break;)
}
```
- if문과 switch문의 차이
  - if문은 조건식 내에 비교 연산을 사용할 수 있기 때문에 switch문보다 더 자주 사용된다. 하지만 if문의 경우 조건식을 위에서부터 차례대로 순차 비교를 하기 때문에 운 나쁘게 맨 밑에 조건이 당첨된다면 그만큼 속도가 느려진다는 문제가 있다. 그래서 비교 연산이 필요 없고 조건을 비교할 대상의 범위가  

# 🟦 반복문
- 종류
  1. for 
  2. for-in
  3. for-of
  4. while

## 🔷 for-loop
## 🔷 for-in-loop
- 향산된 for문이다.
- Java에서는 향상된 for문을 사용할 경우 인덱스 넘버가 없는 애들도 출력이 가능했다. (Set 자료형의 경우)
- JS에서도 인덱스가 없는 자료형의 element를 추출할 때 for-in 반복문을 사용하게 된다.
- 가장 대표적으로는 JavaScript의 객체의 value를 추출할 수 있다.

## 🔷 for-of-loop
- 향산된 for문이다.

# 🟦 함수(function)
## 🔷 정의
- 다양한 작업을 하나의 단위로 묶어놓은 코드블록

## 🔷 함수의 정의 및 사용
1. 함수 선언식
```js
function 함수명(매개변수1, 매개변수2) {
  실행문;
  return이 optional
}

function add(a, b) {
  let sum = a + b;
  return sum;
}
```
2. 함수의 호출
```js
add(1, 2);    // 는 콘솔상에서의 결과값이 없다. return이니
let sumNum = add(1, 2);
console.log(sumNum);    // 으로 해야겠다.
```
3. 함수 표현식(arrow function)
함수 표현식은 _변수에 함수를 할당해서 사용하는 방식_ 이다.
- 메서드의 결과값이 변수에 들어가는게 아니라 함수 자체가 변수에 들어간다.
- 형식
```js
선언자 변수명 = 함수명(매개변수1, 매개변수2) {
  실행문
  return값
}
let sum = function(a, b) {
  return a + b;
}
```
```js
let sum00 = sum(10, 5);   // 함수를 변수(let)에 저장하니까 순서를 지키게 되어 오류가 발생한다.
console.log(sum00);

// 함수 표현식 정의
let sum = function(a, b) {    // 호이스팅
  return a + b;
}
// 함수 호출
sum1 = sum(1,2);
console.log(sum1);
sum2 = sum(3,4);
console.log(sum2);
```
함수 및 함수 표현식의 경우 차이가 없어 보이지만 실행 측면 상에서의 차이가 존재한다. 일반적인 함수 선언의 경우에는 정의 영역이 호출 영역보다 뒤에 있다고 하더라도 정상 작동을 한다.

이는 JS 해석(인터프리터) 엔진이 일반적으로 선언된 함수의 경우 먼저 읽어들이기 때문에(호이스팅) 호출 구문이 선행하더라도 문제가 없다.

그런데 변수에 할당하는 함수 표현식의 경우 let 선언자로 인해 선언된 순서로 읽기 때문에 정의가 먼저 되어야지만 호출이 정상적으로 이루어진다.

4. Function 생성자 함수
```js
let sum = new Function('a', 'b', 'return a + b;');
let sum1 = sum(1, 2);
let sum2 = sum(3, 4);
```

## 🔷 함수를 사용하는 이유
- 특정 기능을 하는 코드 블록을 작성하면 해당 함수가 갖는 기능이 필요할 때마다 호출만 하면 되기 때문에 효율성이 높다. 같은 코드를 재작성할 필요가 없기 때문에 장점이 있고, 또한 기능 변경이 일어날 때 전체 코드를 수정하는 것이 아니라 특정 함수 내부의 로직만 수정하면 호출 부분은 자동으로 수정사항이 반영된다.

1. 코드의 재사용성이 높다.
2. 코드의 유지보수성이 높다.
3. 함수의 이름이 직관적인 경우에 코드 가독성이 높다.

# 🟦 JavaScript 내장 객체
- 내장 객체가 가지고 있는 다양한 함수(메서드)의 기능을 파악하고 있을 때, 이를 조합하여 사용자 정의 함수 및 메서드를 정의하게 되면 가독성이 높은 코드를 작성할 수 있다.

## 🔷 Object 객체
내장 객체(Built-in Object)는 브라우저의 JS 엔진에 내장된 객체를 의미하는데, Object 객체는 모든 JS의 루트 객체에 해당한다. JS에는 String / Number / Date / Array / Math 등 다양한 객체가 존재한다.
```js
// 빈 객체 생성
let person = new Object();
// 멤버 설정
person.fName = '영';
person.lName = '김';
person.age = 20;
person.getFullName = function() {
  return this.lName + ' ' + this.fName;
}
console.log(person.getFullName());  // 결과값 : 김 영
```
이상의 코드에서 person이라는 객체의 property는 fName / lName / age / getFullName이라는 key를 가지고 있고 value로 각각 string / string / number / 함수가 담겨있다. 그렇다면 person객체에 있는 getFullName()은 함수니 method라고 할 수 있겠다.

## 🔷 String 객체
1. length - 문자열 길이를 반환

2. indexOf() - 문자열 내에 특정 문자열이 존재하는지를 찾고, 있다면 문자열이 시작되는 index를 return한다. 없으면 -1을 return한다.
3. lastIndexOf() - argument로 들어간 문자열이 둘 이상 반복되는 경우 마지막에 발견된 문자열을 return한다.
4. silce() - slice(시작값, 한계값); 시작값부터 한계값 미만까지 출력된다.
5. substring() - silce()와 동일하지만 음수값을 허용하지 않는다.
6. substr() - 특정 index부터 argument의 개수의 문자를 뽑아낸다. 
```js
let strFruits = 'Apple, Banana, Kiwi';
let banana = strFruits.slice(7,13);
console.log(banana);  // slice(시작값, 한계값); 한계값 미만까지 출력된다.
let slicedFruits = strFruits.slice(7);  // 7번지부터 끝까지
console.log(slicedFruits);
// python에서는 마이너스 인덱스가 있기는 한데, JS에서는 없다. 하지만 slice()의 argument로 마이너스값을 넣어줄 수는 있다.
console.log(strFruits.slice(-12));  // 뒤에서부터 -1, -2, -3 ...

console.log(strFruits.substring(7,13)); // 결과값은 silce(7,13)과 동일함
console.log(strFruits.substr(7,6));   // 결과값은 silce(7,13), substring(7,13)와 동일함
```
7. replace() - 첫번째 argument와 일치하는 문자열 중 처음 발견된 것을 두 번째 argument로 대체한다. `i`를 사용하면 덜 까다롭게 문자열을 찾는다. `g`는 처음 문자열이 아니라 일치하는 모든 문자열을 찾는다.
```js
let welcomSentence = 'Please visit Seoul and Seoul';
let modifiedSentence = welcomSentence.replace('Seoul', 'Jeju');
console.log(modifiedSentence);
// replace()는 argument와 일치하는 문자열 중 처음 발견된 것을 두 번째 argument로 대체한다.
let modifiedSentence2 = welcomSentence.replace('SEOUL', 'Jeju');
console.log(modifiedSentence2);
let modifiedSentence3 = welcomSentence.replace(/SEOUL/i, 'Jeju');
console.log(modifiedSentence3);
// SEOUL은 찾고자하는 문자열 i는 insensitive의 약자로 덜 까다롭게 굴겠다는 것이다.
let modifiedSentence4 = welcomSentence.replace(/Seoul/g, 'Jeju');
console.log(modifiedSentence4);
```
8. toUpperCase(), toLowerCase()

9. concat() - 2개 이상의 문자열을 하나로 합친다.
10. trim() - 문자열의 앞 뒤 공백을 삭제한다.
11. split() - slice()와 비슷한 기능이지만 return 자료형이 다르다. 즉 split()의 결과값의 자료형은 Array에 해당한다. argument로 넣은 '-'를 만날 때마다 배열의 element로 집어넣는다고 볼 수 있다.
```js
let birthday = '1988-07-09';
let birthdayResult = birthday.split('-');
console.log(birthdayResult);  // 결과값 : ['1988', '07', '09' ]
```

## 🔷 Number 객체

# 🚨발생한 문제


# 📖 복습 & 확인
✔️ 내용
💡📌📍🚩🚨⚠️